{"name":"Grape-Ape-Rails","tagline":"When you absolutely need some Grape in your Vanilla Rails, without all the setup hassle.","body":"# GrapeApeRails\r\n\r\nThe general purpose of this gem is to wrap the various best practices of integrating GrapeAPI within the context of a Rails app\r\ninto an easy-to-use macro-framework and DSL, plus some opinionated value-adds and features. Basically, Grape and Rails play\r\ntogether great, but can be tricky to integrate in a robust, clean way; GrapeApeRails (hopefully) makes your life easier.\r\n\r\n## Features/Opinions\r\n\r\nGrapeApeRails is opinionated. The goal is to make integration easier, so GrapeApeRails makes a number of integration decisions for you:\r\n\r\n* API endpoints respond with JSON\r\n* API endpoints expect serialized JSON strings for POST and PUT bodies\r\n* JSON responses are wrapped in a structure that mostly resembles the JSON-RPC spec\r\n* GrapeApeRails APIs are header-versioned using the 'Accept' HTTP header\r\n* API endpoints automatically handle locale if provided (either via params[:locale] or the 'Accept-Language' header) and use the `http_accept_language` middleware\r\n* GrapeApeRails provides an ActiveSupport::Notification that can be suscribed to for logging/injection into the Rails log\r\n* Pagination support is already included for all endpoints via the [grape-kaminari gem](https://github.com/monterail/grape-kaminari)\r\n* Rails cache support is already included for all endpoints via the [grape-rails-cache gem](https://github.com/monterail/grape-rails-cache)\r\n* API endpoints are automagically documented into [Swagger API XML docs](https://helloreverb.com/developers/swagger), presented by your API via mounted endpoints\r\n* Swagger-documented APIs are automatically separated into different URIs by API version\r\n\r\nIf these opinions and features align closely to what you're planning to build for your API, I think you'll find GrapeApeRails very useful.\r\nIf you're intending to build something very different from the above, you're probably better off integrating Grape on your own, or looking at alternate projects\r\nlike [Rails::API](https://github.com/rails-api/rails-api).\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'grape_ape_rails'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install grape_ape_rails\r\n\r\n## Setup\r\n\r\nFirst, GrapeApeRails needs an initializer as `config/initializers/grape_ape_rails.rb`\r\n\r\nThe easiest way to do this is to run the handy rails generator command:\r\n\r\n```ruby\r\nrails g grape_ape_rails:setup\r\n```\r\n\r\nThis will:\r\n* create your initializer with some default settings, based on how you answer the questions\r\n* add a `tilt.root` Rack config to your application.rb for use with Rabl templates\r\n\r\nNext, you'll need to create your `API::Base` class, which serves as the starting point for all\r\nof your API endpoints and all versions of your API. By default, GrapeApeRails looks for a\r\nbase.rb file in `app/controllers/api/base.rb`\r\n\r\n```ruby\r\n# app/controllers/api/base.rb\r\nmodule API\r\n  class Base < GrapeApeRails::API\r\n    grape_apis do\r\n      api \"V1\" do\r\n        # ... mounts go here\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNOTE: the api name needs to look like a class name, with camelcase (e.g. \"V1\" or \"AdminV1\").\r\nThis actually _is_ the class that GrapeApeRails will then expect you to define for exposing your endpoints.\r\nInternally, Grape will translate this to an under-dotted version name (e.g \"v1\" or \"admin.v1\")\r\nand this is what will be expected in the Accept header string provided by the requestor.\r\n\r\n## Usage\r\n\r\nNow that you've got your base.rb ready, you need to mount your various resources/endpoints. This is\r\ndone via the `grape_mount` command. These should generally be mounted as pluralized resource names.\r\n\r\n```ruby\r\n# inside the base.rb ...\r\napi \"V1\" do\r\n  grape_mount :widgets\r\n  grape_mount :robots\r\n  grape_mount :pirates\r\n  # ... etc\r\nend\r\n```\r\n\r\nIf you try to spin up your app now, it will complain that you need to actually create the class files\r\nfor each of the resources you've mounted. So let's do that in a 'v1' subfolder...\r\n\r\n```ruby\r\n# app/controllers/api/v1/widgets.rb\r\nmodule API\r\n  module V1\r\n    class Widgets < GrapeApeRails::API\r\n      include GrapeApeRails::Handlers::All\r\n\r\n      resource :widgets do\r\n        desc \"Get a single Widget\"\r\n        get ':id', rabl: 'v1/widget' do\r\n          @widget = Widget.find(params[:id])\r\n          @widget\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIn this case, I've simply created a `/widgets/:id` endpoint, but you can define whatever endpoints you want.\r\nBecause you've defined this within the :widgets resource, the API will assume all of these endpoints begin\r\nwith `/widgets`\r\n\r\n### Rabl\r\n\r\nIn my example, I'm using the default Rabl-based templating. The `rabl` parameter expects a path to the .rabl template file,\r\nas found within /app/views/api/ ... all Rabl functionality should work as expected.\r\n\r\n### ActiveModel Serializers\r\n\r\nIf you'd prefer ActiveModel Serializers over Rabl, GrapeApeRails supports that as well via a custom Grape formatter\r\ncalled `Grape::Formatter::GarActiveModelSerializers`. To use it, just override the `formatter` within each of your API\r\nclasses.\r\n\r\n```ruby\r\nmodule API\r\n  module V1\r\n    class Monkeys < GrapeApeRails::API\r\n      include GrapeApeRails::Handlers::All\r\n\r\n      formatter :json, Grape::Formatter::GarActiveModelSerializers\r\n\r\n      resource :monkeys do\r\n        desc \"Get a single Monkey\"\r\n        get ':id' do\r\n          @monkey = Monkey.find(params[:id])\r\n          @monkey\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIn this case, it's expected that you've defined a MonkeySerializer class in your models directory, as usual with ActiveModelSerializers.\r\n\r\n### JSON Response Structures\r\n\r\nSimilar to the JSON-RPC spec, endpoints exposed using GrapeApeRails will present either a `result` hash or an `error` hash.\r\nThe error hash will be composed of a `code` (a machine-friendly enum-like uppercase string) and a\r\nmessage (human-friendly, user-presentable message that includes the code inside brackets).\r\n\r\n```ruby\r\n# Successful response\r\n{\r\n  \"result\" : {\r\n    \"widgets\" : [\r\n      { \"id\" : 1, \"name\" : \"Fancy Widget\" },\r\n      { \"id\" : 2, \"name\" : \"Other Thing\" },\r\n      ...\r\n    ]\r\n  }\r\n}\r\n\r\n# Error response\r\n{\r\n  \"error\" : {\r\n    \"code\" : \"UNAUTHORIZED\",\r\n    \"message\" : \"[UNAUTHORIZED] Requires a valid user authorization\"\r\n  }\r\n}\r\n```\r\n\r\nIn the case of a validation error on a resource, there will additionally be a `data` key inside the error hash that includes Rails-style validation errors.\r\n\r\nIMPORTANT: In defining response structures, I made the decision (based on lots of research) to go with a plural resource key and an _always-array_ approach in the\r\nresponse hash. To put it another way:\r\n\r\nIf you ask for /widgets/1 you will get\r\n\r\n`{ \"result\" : { \"widgets\" : [ {<widget>} ] } }`\r\n\r\nand if you ask for /widgets you will get\r\n\r\n`{ \"result\" : { \"widgets\" : [ {widget1}, {widget2}, {widget3}, ... ] } }`\r\n\r\n### Pagination\r\n\r\nGrapeApeRails uses Kaminari for pagination via the [grape-kaminari](https://github.com/monterail/grape-kaminari) gem.\r\n\r\nEnabling pagination on a resource is super-simple:\r\n\r\n```ruby\r\n# inside your API resource class...\r\ndesc \"Return a list of Widgets\"\r\nparams :pagination do\r\n  optional :page,     type: Integer\r\n  optional :per_page, type: Integer\r\n  optional :offset,   type: Integer\r\nend\r\npaginate per_page: 30\r\nget '/', rabl: 'v1/widgets' do\r\n  @widgets = paginate(@widgets)\r\nend\r\n```\r\n\r\n_From the grape-kaminari docs:_\r\n\r\nNow you can make a HTTP request to your endpoint with the following parameters\r\n\r\n- `page`: your current page (default: 1)\r\n- `per_page`: how many to record in a page (default: 10)\r\n- `offset`: the offset to start from (default: 0)\r\n\r\n```\r\ncurl -v http://host.dev/widgets?page=3&offset=10\r\n```\r\n\r\nand the response will be paginated and also will include pagination headers\r\n\r\n```\r\nX-Total: 42\r\nX-Total-Pages: 5\r\nX-Page: 3\r\nX-Per-Page: 10\r\nX-Next-Page: 4\r\nX-Prev-Page: 2\r\nX-Offset: 10\r\n```\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}